### quickfix

quickfix

## Config Files

- **site_config.json** ‚Äì Site-specific settings (DB credentials, API keys).  
  If wrong ‚Üí site may fail to connect to DB/services.

- **common_site_config.json** ‚Äì Bench-wide settings shared by all sites (Redis, ports, workers).  
  ‚ö†Ô∏è Putting a secret here exposes it to all sites ‚Üí security risk & cross-site access.

- **Procfile** ‚Äì Defines processes started by `bench start`.  
  If incorrect ‚Üí required services won‚Äôt start.

- **hooks.py** ‚Äì App configuration (scheduled jobs, events, permissions).  
  If misconfigured ‚Üí background jobs or triggers may fail.

---

## Bench Processes (`bench start`)

- **web** ‚Äì Serves HTTP requests.  
- **worker** ‚Äì Runs background jobs (emails, reports, long tasks).  
- **scheduler** ‚Äì Queues periodic jobs.  
- **socketio** ‚Äì Enables real-time updates.

**If the worker crashes:**  
Background jobs stop running and remain queued in Redis until the worker restarts.

### Installation

You can install this app using the [bench](https://github.com/frappe/bench) CLI:

```bash
cd $PATH_TO_YOUR_BENCH
bench get-app $URL_OF_THIS_REPO --branch develop
bench install-app quickfix
```

### Contributing

This app uses `pre-commit` for code formatting and linting. Please [install pre-commit](https://pre-commit.com/#installation) and enable it for this repository:

```bash
cd apps/quickfix
pre-commit install
```

Pre-commit is configured to use the following tools for checking and formatting your code:

- ruff
- eslint
- prettier
- pyupgrade

### License

mit

##
---------------------------------------------------------------------------------------------------------------------------------------------------------

## Step 1 ‚Äì Routing

- **/api/method/quickfix.api.get_job_summary**  
  Calls the `get_job_summary` function in `quickfix/api.py`.  
  Frappe imports the dotted path and runs the whitelisted method.

- **/api/resource/Job Card/JC-2024-0001**  
  Uses Frappe‚Äôs REST API to fetch the `Job Card` document from the database.  
  Unlike `/api/method/`, it uses built-in CRUD, not a custom function.

- **/track-job**  
  Handled by files in the `www` folder (e.g., `www/track-job.py` or `.html`).  
  Frappe auto-maps `www` files to website routes.

## Step 2 ‚Äì Session & CSRF

- **X-Frappe-CSRF-Token**
  - The token comes from the user‚Äôs active session and is generated by Frappe to prevent Cross-Site Request Forgery attacks.
  - It is sent with POST/PUT/DELETE requests and validated on the server.
  - If omitted or invalid ‚Üí the request is rejected with a CSRF validation error (HTTP 403).

- **frappe.session.data**
  - If you run frappe.session.data it should return None.
  - If your run frappe.session it will return user and csrf token.

## Step 3 ‚Äì Error Visibility

- **developer_mode: 1**
  - When a Python exception occurs in a whitelisted method, the browser receives:
    - Full traceback
    - Error type and message
    - File path and line number
  - This helps developers debug issues quickly.

- **developer_mode: 0**
  - If the bench is in local then full traceback will take place as same as developer_mode:1
  - When the bench is in procudtion the browser receives a generic error message (e.g., "Internal Server Error").
  - Detailed traceback is hidden to prevent exposing sensitive information.
  - This is important for production to protect system details and security.

- **Where production errors go**
  - Errors are logged in:
    - `frappe.log_error()` logs
    - Error Log DocType in the database
    - Bench/server log files (`logs/` directory)

## Step 4 ‚Äì Permission Check Location

 1. `frappe.get_doc("Job Card", name)`

   * Called without `ignore_permissions=True`, Frappe checks document permissions.
   * It verifies whether the current user can access the **Job Card**.

 2. Unassigned QF Technician access

   * If an unassigned **QF Technician** attempts access:

   * **PermissionError** is raised.
   * Browser receives **HTTP 403 Forbidden**.
   * Access is denied.

 3. Where the request stops

   * Request stops at Frappe‚Äôs **Document permission layer**.
   * Checks include roles, user permissions, assignments, and sharing rules.
   * If denied, execution halts at `frappe.get_doc()`.


## Part A ‚Äì Table Naming (Bench Console)

### 1. Tables matching `%Job%`

**Command**

```sql id="5c9d2f"
frappe.db.sql("SHOW TABLES LIKE '%Job%'")
```
**Output**

tabJob Card
tabScheduled Job Log
tabScheduled Job Type

**Explanation**

* Frappe stores each **DocType** as a table prefixed with `tab`.
* Format: `tab<DocType Name>`
* Example: `Job Card` ‚Üí `tabJob Card`

---

### 2. Structure of `tabJob Card`

**Command**

```sql id="8b2d5a"
frappe.db.sql("DESCRIBE `tabJob Card`", as_dict=True)
```

### 3. Recognised columns

Common system fields:

* `name` ‚Äì Primary key
* `creation` ‚Äì Created timestamp
* `modified` ‚Äì Last modified time
* `owner` ‚Äì Document creator
* `docstatus` ‚Äì Draft/Submitted/Cancelled status

These fields are automatically added by Frappe to manage documents.

## Part D ‚Äì DocStatus Transitions

### 1. DocStatus values

* **0 ‚Äì Draft** 
* **1 ‚Äì Submitted** 
* **2 ‚Äì Cancelled** 

### 2. Submitted & Cancelled behavior

* `doc.save()` on **Submitted** ‚Üí  Not allowed (except fields with *Allow on Submit*).
* `doc.submit()` on **Cancelled** ‚Üí  Not allowed. Must **Amend ‚Üí Submit** to keep audit trail.


### 3. "Document has been modified after you opened it"

Occurs when:

* Another user/script updated the document.
* The `modified` timestamp changed.

**Purpose:** Prevents overwriting newer changes.

## Part E ‚Äì Dangerous Patterns (Fix)

###  Issues

1. **`self.save()` inside `validate()`**

   * Causes recursion and breaks the document lifecycle.
   * `validate()` already runs during save.

2. **Unsafe update to another DocType**

   * Directly modifying Spare Part stock can cause data inconsistency.
   * No protection against concurrent updates.


###  Corrected approach

* Calculate totals inside `validate()` without calling `save()`.
* Update related documents within the same transaction so changes stay consistent.
* Ensure updates roll back automatically if the main document fails.


# Child Table Internals

## Auto-set Columns on Child Rows
When a row is added to `Job Card.parts_used` and saved, Frappe automatically sets:

- **parent** ‚Äì Parent document name (Job Card ID)
- **parenttype** ‚Äì Parent DocType ("Job Card")
- **parentfield** ‚Äì Child table fieldname ("parts_used")
- **idx** ‚Äì Row order in the table

---

## Child Table DB Name
The database table for **Part Usage Entry** DocType is:

tabPart Usage Entry

Frappe adds the `tab` prefix to all DocType tables.

---

## idx Behavior After Deletion
If the row at `idx = 2` is deleted and the document is saved:

- Remaining rows are automatically reordered.
- `idx` values are reset sequentially starting from 1.
- No gaps are left in row numbering.

---------------------------------------------------------------------------------------------------------------------------------------------------------

# Rename & Unique Constraints

## Rename Document
- After renaming a Technician, linked Job Cards **auto-update** the `assigned_technician` field.
- Frappe updates all Link fields to maintain referential integrity.
- Link fields store the document name (primary key), so references stay valid.

## Track Changes
- Records field-level changes in the Version log.
- Shows old value, new value, user, and timestamp.
- It does **not control link updates**.

## Unique Constraints

**Unique field in DocType**
- Enforced at database level.
- Prevents duplicates automatically.
- Reliable and fast.

**`frappe.db.exists()` in validate()**
- Enforced at application level.
- Can be bypassed in race conditions.
- Used for conditional uniqueness.

**Difference:** Database-level uniqueness is safer; validate() checks are for custom logic.

## Document Permissions Check

The output shows all permission values as 0, meaning the current user has no access to the Job Card. This happens when the user has no role permissions, is not the document owner, and the document has not been shared with them. The `frappe.get_doc_permissions(doc)` function returns the effective permissions for the logged-in user, which vary based on roles, ownership, and sharing settings.

## Recursion Pitfall in `on_update()` ‚Äî Short Note

###  Wrong Pattern

```python
def on_update(self):
    self.save()  # causes infinite recursion
```

###  Why It‚Äôs Dangerous

`save()` triggers the document lifecycle again ‚Üí `on_update()` runs repeatedly ‚Üí infinite loop, timeouts, high CPU usage.

### Correct Pattern

Modify fields directly (no save needed):

```python
def on_update(self):
    self.status = "Updated"  #  safe
```

Or update DB without triggering hooks:

```python
frappe.db.set_value(self.doctype, self.name, "status", "Updated")
```

---------------------------------------------------------------------------------------------------------------------------------------------------------

## Part B ‚Äî Upgrade Friction Analysis (Short)

###  Risk: Missing `super().validate()` in override_doctype_class

If Frappe adds new validations in `Job Card.validate()` and `super()` is not called:

* Core validations are skipped
* New framework checks won‚Äôt run
* Invalid data may be saved
* Upgrades can silently break business rules

---

###  Test to Catch This

Try inserting a Job Card that violates a core validation.

**Expected:** Insert fails
**If it succeeds:** `super().validate()` is missing and core logic is bypassed.

---

###  Why `doc_events` is Safer

* Preserves core logic
* Upgrade-friendly
* Multiple apps can hook safely
* No need to maintain `super()` chain

**override_doctype_class**

* Replaces core controller
* High upgrade risk
* Must maintain compatibility manually

**Rule:** Prefer `doc_events`; use override only when modifying core behavior is unavoidable.


## Part B ‚Äì Multiple Validate Handlers

### Execution Order

When saving a **Job Card**, Frappe executes validate handlers in the following order:

1. **Controller `validate()` method**  
2. **`doc_events` handler for Job Card**  
3. **Wildcard `"*"` handler** (if defined)  

### If Both Handlers Raise `frappe.ValidationError`

- Execution stops at the first error.  
- Remaining handlers will **not** run.  
- Only **one error message** appears on the Desk.  

### `"*"` and Specific DocType Handler Together

- If both are registered for the same event:  
  - Both handlers run in sequence.  
  - **Specific DocType handler runs before wildcard**.  
  - If the first handler throws an error, the wildcard handler will **not** execute.

---------------------------------------------------------------------------------------------------------------------------------------------------------

# Part ‚Äì Asset Hooks & Client Scripts (QuickFix)

## 1. app_include_js vs web_include_js

### app_include_js
Loads a JavaScript file only in the **Frappe Desk** (for logged-in users).

**Used for:**
- Internal UI tweaks
- Employee workflow helpers
- Desk notifications or shortcuts

### web_include_js
Loads a JavaScript file only on **Website/Portal pages**.

**Used for:**
- Customer portal enhancements
- Web form validation
- Public-facing UI interactions

---

## 2. DocType Client Scripts

### doctype_js (Job Card)
Runs only when the **Job Card form** is opened.

**Use cases:**
- Field validation
- Auto-calculations
- Dynamic field behavior

### doctype_list_js (Job Card)
Runs on the **Job Card list view**.

**Use cases:**
- Custom list buttons
- Row highlighting
- Bulk actions & filters

---

## 3. doctype_tree_js (Not applicable for Job Card)

Tree view is used for DocTypes with hierarchical (parent‚Äìchild) data.

**Examples:**
- Chart of Accounts
- Item Group
- Territory
- Department

**Why use tree view?**
- Visualize hierarchy
- Easy navigation
- Manage parent-child relationships

Job Card does not use a tree view because it has no hierarchy.

---

## 4. Build & Cache Busting

### What it does
- Compiles and bundles JS/CSS files
- Generates hashed filenames
- Updates asset manifest

### Why cache busting is needed
Browsers cache JS files. After changes, old files may still load.

Cache busting ensures:
- Latest JS is loaded
- Prevents stale scripts
- Avoids debugging issues

---

## 5. When to Run bench build
Run this command after:
- Modifying JS or CSS
- Adding asset hooks
- Updating client scripts
- Deploying to production

------------------------------------------------------------------------------------------------------------------------------------------------------------------

## Override `frappe.client.get_count` ‚Äì Internal Notes

### ‚úÖ Tests

**1. Confirm override is called**

* Call: `frappe.client.get_count("Job Card")`
* Verify: New entry in **Audit Log** with action `count_queried`.

**2. Confirm original logic still works**

* Compare:

  * `frappe.client.get_count("Job Card")`
  * `frappe.db.count("Job Card")`
* Both counts must match.

**3. Confirm other apps are not broken**

* Any app calling `frappe.client.get_count` still receives correct count.
* No errors or behavior changes except logging.

---

### üîÅ override_whitelisted_methods vs Monkey Patching

| Feature     | Hook Override | Monkey Patching   |
| ----------- | ------------- | ----------------- |
| Mechanism   | hooks.py      | import-time code  |
| Visibility  | Explicit      | Hidden            |
| Safety      | Upgrade-safe  | Breaks on updates |
| Reversible  | Yes           | No                |
| Recommended | ‚úÖ Yes        | ‚ùå Avoid          |

**When to use**

* Use **override_whitelisted_methods** for production-safe customization.
* Use monkey patching only for temporary debugging or experiments.

---

### ‚ö†Ô∏è Multiple Apps Overriding Same Method

If two apps override the same method:

* The app **last in apps.txt order wins**.
* Only one override runs.
* No automatic chaining.

---

### ‚ö†Ô∏è Signature Mismatch

Override must match original signature:

```python id="j6db9x"
get_count(doctype, filters=None, debug=False, cache=False)
```

If arguments differ, Frappe cannot map parameters ‚Üí **TypeError**.

**Example Error**

```
TypeError: custom_get_count() missing required positional argument 'doctype'
```

**When it occurs**

* Missing parameters
* Different parameter order
* Extra required parameters


## Fieldname Collision Risk

When adding Custom Fields in Frappe, using a fieldname that may later be introduced by the core framework for the same DocType can lead to a **fieldname collision**.

### Effects
- Migration failure due to duplicate column creation
- Database schema conflicts
- Possible data loss
- UI inconsistencies or unexpected behavior

### Prevention
Use unique, app-prefixed fieldnames to avoid conflicts with future Frappe updates.

**Recommended pattern:**
- `qf_priority`
- `qf_service_status`
- `qf_internal_notes`

Using a prefix (e.g., `qf_` for QuickFix) ensures custom fields remain isolated from core changes.

---

## Patch Ordering & `patches.txt`

If Patch 1 creates a Custom Field and Patch 2 reads or updates it, they must be listed as **separate entries** in `patches.txt`.

### Why This Matters
- Patches run sequentially in the listed order
- Ensures the field exists before being accessed
- Allows safe resume if migration fails
- Simplifies debugging and rollback

### Best Practice
```txt
# patches.txt
quickfix.patches.v1_0.create_custom_fields
quickfix.patches.v1_0.update_custom_field_values

Patch Safety ‚Äì Quick Revision
_qf_patched Guard

Prevents a monkey patch from running multiple times during reloads.

Without it:

Infinite recursion

Duplicate validations/DB writes

Performance issues

Unpredictable bugs

Why monkey_patches.py (not __init__.py)?

Centralized, auditable patch location

Predictable execution

Easier debugging & disabling

Lower upgrade risk

Escalation Order (Use in this order)

doc_events ‚Üí safest, upgrade-friendly

override_doctype_class ‚Üí controlled controller override

override_whitelisted_methods ‚Üí alters API behavior

monkey patch ‚Üí last resort, high risk

üëâ Deeper override = higher fragility.

Monkey Patch Risks

Breaks after updates

Hidden side effects

Hard to maintain

Rule

If hooks can solve it, never use a monkey patch.



 

  


