### quickfix

quickfix

## Config Files

- **site_config.json** – Site-specific settings (DB credentials, API keys).  
  If wrong → site may fail to connect to DB/services.

- **common_site_config.json** – Bench-wide settings shared by all sites (Redis, ports, workers).  
  ⚠️ Putting a secret here exposes it to all sites → security risk & cross-site access.

- **Procfile** – Defines processes started by `bench start`.  
  If incorrect → required services won’t start.

- **hooks.py** – App configuration (scheduled jobs, events, permissions).  
  If misconfigured → background jobs or triggers may fail.

---

## Bench Processes (`bench start`)

- **web** – Serves HTTP requests.  
- **worker** – Runs background jobs (emails, reports, long tasks).  
- **scheduler** – Queues periodic jobs.  
- **socketio** – Enables real-time updates.

**If the worker crashes:**  
Background jobs stop running and remain queued in Redis until the worker restarts.

### Installation

You can install this app using the [bench](https://github.com/frappe/bench) CLI:

```bash
cd $PATH_TO_YOUR_BENCH
bench get-app $URL_OF_THIS_REPO --branch develop
bench install-app quickfix
```

### Contributing

This app uses `pre-commit` for code formatting and linting. Please [install pre-commit](https://pre-commit.com/#installation) and enable it for this repository:

```bash
cd apps/quickfix
pre-commit install
```

Pre-commit is configured to use the following tools for checking and formatting your code:

- ruff
- eslint
- prettier
- pyupgrade

### License

mit

##
---------------------------------------------------------------------------------------------------------------------------------------------------------

## Step 1 – Routing

- **/api/method/quickfix.api.get_job_summary**  
  Calls the `get_job_summary` function in `quickfix/api.py`.  
  Frappe imports the dotted path and runs the whitelisted method.

- **/api/resource/Job Card/JC-2024-0001**  
  Uses Frappe’s REST API to fetch the `Job Card` document from the database.  
  Unlike `/api/method/`, it uses built-in CRUD, not a custom function.

- **/track-job**  
  Handled by files in the `www` folder (e.g., `www/track-job.py` or `.html`).  
  Frappe auto-maps `www` files to website routes.

## Step 2 – Session & CSRF

- **X-Frappe-CSRF-Token**
  - The token comes from the user’s active session and is generated by Frappe to prevent Cross-Site Request Forgery attacks.
  - It is sent with POST/PUT/DELETE requests and validated on the server.
  - If omitted or invalid → the request is rejected with a CSRF validation error (HTTP 403).

- **frappe.session.data**
  - If you run frappe.session.data it should return None.
  - If your run frappe.session it will return user and csrf token.

## Step 3 – Error Visibility

- **developer_mode: 1**
  - When a Python exception occurs in a whitelisted method, the browser receives:
    - Full traceback
    - Error type and message
    - File path and line number
  - This helps developers debug issues quickly.

- **developer_mode: 0**
  - If the bench is in local then full traceback will take place as same as developer_mode:1
  - When the bench is in procudtion the browser receives a generic error message (e.g., "Internal Server Error").
  - Detailed traceback is hidden to prevent exposing sensitive information.
  - This is important for production to protect system details and security.

- **Where production errors go**
  - Errors are logged in:
    - `frappe.log_error()` logs
    - Error Log DocType in the database
    - Bench/server log files (`logs/` directory)

## Step 4 – Permission Check Location

 1. `frappe.get_doc("Job Card", name)`

   * Called without `ignore_permissions=True`, Frappe checks document permissions.
   * It verifies whether the current user can access the **Job Card**.

 2. Unassigned QF Technician access

   * If an unassigned **QF Technician** attempts access:

   * **PermissionError** is raised.
   * Browser receives **HTTP 403 Forbidden**.
   * Access is denied.

 3. Where the request stops

   * Request stops at Frappe’s **Document permission layer**.
   * Checks include roles, user permissions, assignments, and sharing rules.
   * If denied, execution halts at `frappe.get_doc()`.


## Part A – Table Naming (Bench Console)

### 1. Tables matching `%Job%`

**Command**

```sql id="5c9d2f"
frappe.db.sql("SHOW TABLES LIKE '%Job%'")
```
**Output**

tabJob Card
tabScheduled Job Log
tabScheduled Job Type

**Explanation**

* Frappe stores each **DocType** as a table prefixed with `tab`.
* Format: `tab<DocType Name>`
* Example: `Job Card` → `tabJob Card`

---

### 2. Structure of `tabJob Card`

**Command**

```sql id="8b2d5a"
frappe.db.sql("DESCRIBE `tabJob Card`", as_dict=True)
```

### 3. Recognised columns

Common system fields:

* `name` – Primary key
* `creation` – Created timestamp
* `modified` – Last modified time
* `owner` – Document creator
* `docstatus` – Draft/Submitted/Cancelled status

These fields are automatically added by Frappe to manage documents.

## Part D – DocStatus Transitions

### 1. DocStatus values

* **0 – Draft** 
* **1 – Submitted** 
* **2 – Cancelled** 

### 2. Submitted & Cancelled behavior

* `doc.save()` on **Submitted** →  Not allowed (except fields with *Allow on Submit*).
* `doc.submit()` on **Cancelled** →  Not allowed. Must **Amend → Submit** to keep audit trail.


### 3. "Document has been modified after you opened it"

Occurs when:

* Another user/script updated the document.
* The `modified` timestamp changed.

**Purpose:** Prevents overwriting newer changes.

## Part E – Dangerous Patterns (Fix)

###  Issues

1. **`self.save()` inside `validate()`**

   * Causes recursion and breaks the document lifecycle.
   * `validate()` already runs during save.

2. **Unsafe update to another DocType**

   * Directly modifying Spare Part stock can cause data inconsistency.
   * No protection against concurrent updates.


###  Corrected approach

* Calculate totals inside `validate()` without calling `save()`.
* Update related documents within the same transaction so changes stay consistent.
* Ensure updates roll back automatically if the main document fails.


# Child Table Internals

## Auto-set Columns on Child Rows
When a row is added to `Job Card.parts_used` and saved, Frappe automatically sets:

- **parent** – Parent document name (Job Card ID)
- **parenttype** – Parent DocType ("Job Card")
- **parentfield** – Child table fieldname ("parts_used")
- **idx** – Row order in the table

---

## Child Table DB Name
The database table for **Part Usage Entry** DocType is:

tabPart Usage Entry

Frappe adds the `tab` prefix to all DocType tables.

---

## idx Behavior After Deletion
If the row at `idx = 2` is deleted and the document is saved:

- Remaining rows are automatically reordered.
- `idx` values are reset sequentially starting from 1.
- No gaps are left in row numbering.

---------------------------------------------------------------------------------------------------------------------------------------------------------

# Rename & Unique Constraints

## Rename Document
- After renaming a Technician, linked Job Cards **auto-update** the `assigned_technician` field.
- Frappe updates all Link fields to maintain referential integrity.
- Link fields store the document name (primary key), so references stay valid.

## Track Changes
- Records field-level changes in the Version log.
- Shows old value, new value, user, and timestamp.
- It does **not control link updates**.

## Unique Constraints

**Unique field in DocType**
- Enforced at database level.
- Prevents duplicates automatically.
- Reliable and fast.

**`frappe.db.exists()` in validate()**
- Enforced at application level.
- Can be bypassed in race conditions.
- Used for conditional uniqueness.

**Difference:** Database-level uniqueness is safer; validate() checks are for custom logic.

## Document Permissions Check

The output shows all permission values as 0, meaning the current user has no access to the Job Card. This happens when the user has no role permissions, is not the document owner, and the document has not been shared with them. The `frappe.get_doc_permissions(doc)` function returns the effective permissions for the logged-in user, which vary based on roles, ownership, and sharing settings.

## Recursion Pitfall in `on_update()` — Short Note

###  Wrong Pattern

```python
def on_update(self):
    self.save()  # causes infinite recursion
```

###  Why It’s Dangerous

`save()` triggers the document lifecycle again → `on_update()` runs repeatedly → infinite loop, timeouts, high CPU usage.

### Correct Pattern

Modify fields directly (no save needed):

```python
def on_update(self):
    self.status = "Updated"  #  safe
```

Or update DB without triggering hooks:

```python
frappe.db.set_value(self.doctype, self.name, "status", "Updated")
```

---------------------------------------------------------------------------------------------------------------------------------------------------------

## Part B — Upgrade Friction Analysis (Short)

###  Risk: Missing `super().validate()` in override_doctype_class

If Frappe adds new validations in `Job Card.validate()` and `super()` is not called:

* Core validations are skipped
* New framework checks won’t run
* Invalid data may be saved
* Upgrades can silently break business rules

---

###  Test to Catch This

Try inserting a Job Card that violates a core validation.

**Expected:** Insert fails
**If it succeeds:** `super().validate()` is missing and core logic is bypassed.

---

###  Why `doc_events` is Safer

* Preserves core logic
* Upgrade-friendly
* Multiple apps can hook safely
* No need to maintain `super()` chain

**override_doctype_class**

* Replaces core controller
* High upgrade risk
* Must maintain compatibility manually

**Rule:** Prefer `doc_events`; use override only when modifying core behavior is unavoidable.


## Part B – Multiple Validate Handlers

### Execution Order

When saving a **Job Card**, Frappe executes validate handlers in the following order:

1. **Controller `validate()` method**  
2. **`doc_events` handler for Job Card**  
3. **Wildcard `"*"` handler** (if defined)  

### If Both Handlers Raise `frappe.ValidationError`

- Execution stops at the first error.  
- Remaining handlers will **not** run.  
- Only **one error message** appears on the Desk.  

### `"*"` and Specific DocType Handler Together

- If both are registered for the same event:  
  - Both handlers run in sequence.  
  - **Specific DocType handler runs before wildcard**.  
  - If the first handler throws an error, the wildcard handler will **not** execute.



 

  


